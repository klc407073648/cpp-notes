# 设计模式

本章涉及的内容有：

* 单例模式
* 观察者模式
* 工厂模式
* 抽象工厂模式
* 模板模式
* 策略模式
---

## 单例模式
单例模式(Singleton): 保证一个类仅有一个实例,并提供一个访问它的全局控制点. 比如在加载配置文件时, 可使用该模式. 

- 第一版，最基础的实现 base_use
- 第二版，考虑线程安全和内存泄漏
- 第三版，考虑封装单例智能指针类

[CSDN博客：设计模式之单例模式](https://blog.csdn.net/baidu_15952103/article/details/105024142)

## 观察者模式
观察者模式(Observer): 定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者. 

[CSDN博客：设计模式之观察者模式](https://blog.csdn.net/baidu_15952103/article/details/105024777)

## 工厂模式
工厂模式(Factory): 定义一个用以创建对象的接口, 让子类决定实例化哪个类. 
当遇到需要根据某个前提条件创建不同的类实现时, 会实用工厂模式. 

- 第一版，最基础的实现 base_use
- 第二版，考虑安全构造析构，回收创建指针

[CSDN博客：设计模式之工厂模式](https://blog.csdn.net/baidu_15952103/article/details/105024777)

## 抽象工厂模式
抽象工厂模式(Abstract Factory): 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类. 

两者区别：
Abstract Factory模式为创建一组（有多类）相关或相互依赖对象的接口；
Factory模式为一类对象创建接口或延迟对象的创建到子类中实现。

分析：
工厂负责创建对象,可以让你忽略这个对象的具体创建细节,更多的关注业务,策略负责对象在不同情况下选择最合适的方法,有钱做飞机,没钱坐硬座,让客户自己选,模板负责让方法中不同的地方可以灵活的变化,坐火车,我可以选择自带泡面,也可以选择火车食堂.

## 模板模式
Template 模式是采用继承的方式实现这一点： 将逻辑（算法） 框架放在抽象基类中， 并
定义好细节的接口，子类中实现细节。

## 策略模式
Strategy 模式将逻辑（算法） 封装到一个类（ Context）
里面， 通过组合的方式将具体算法的实现在组合对象中实现， 再通过委托的方式将抽象接口
的实现委托给组合对象实现。 

即将算法的逻辑抽象接口（ DoAction）封装到一个类中（ Context），再
通过委托的方式将具体的算法实现委托给具体的 Strategy 类来实现（ ConcreteStrategeA
类）

Strategy 模式和 Template 模式实际是实现一个抽象接口的两种方式： 继承和组合之
间的区别。

优先使用(对象)组合， 而非(类)继承(Favor Composition Over Inheritance)