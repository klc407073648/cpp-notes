# RocketMQ - 协议

[[toc]]

# RocketMQ的协议

RocketMQ一条消息传输时是由以下几个部分组成的:

![](/_images/micro-services/middleware/rocketmq/协议.png)

调用api发送一条消息，实际api内部会将消息组成上面这四部分发送到Broker，这个过程就是按照协议规定的内容，组装传输体。

分析过程：
1．消息长度：传输体的总长度，固定四个字节存储。
2．序列化类型+消息头长度：固定四个字节存储，第一个字节表示序列化类型，后面三个字节表示消息头长度。
3．消息头内容：存储序列化后的消息头数据。
4．消息体数据：这个就是我们业务刷关的数据内容，即消息体。

这样Broker接收到传输内容，直接取开始的四个字节，就能得知整个消息传输体的长度，能获取到完整的消息传输体，紧接看取后四个字节，就能得知序列化类型和消息头的长度。就能读取消息头的内容且反序列化得到消息头，然后剩下的字节就是消息体。

RocektMQ利用特定顺序+固定长度来实现断句，如此一来就能依次有序地解析出传输的内容，所以协议就是定规矩。

发送方按照规矩来填充相应的数据，接收方按照同样的规矩解析相应的数据，这样他们就能友好地、顺利地沟通了。

然后再来学习下消息头的内容：

![](/_images/micro-services/middleware/rocketmq/消息头内容.png)

* code：请求的时候表示各种业务（发消息、拉消息、获取Topic路信息等等业务），响应的时候HTTP状态码，应该很好理解。
* language：api的语言码。
* version：版本的定义，可以让对方知晓此次消息的版本，来判断兼容老版本等的特殊操作。
* opaque: 本质的实现就是一个自增的int。
* flag：可以标记当前的消息，好让响应方知晓需不要要给当前请求响应。
* remark: 自定义的标记信息，比如写明一些错误原因等等方便定位问题。
* extFields: 扩展字段，不同的请求类型总有一些差异，这个字段就是方便扩展。