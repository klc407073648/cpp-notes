# MySQL进阶 - 索引基础

> 索引是帮助 MySQL **高效获取数据**的**数据结构（有序）**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。

# 为什么需要索引，问题引出

![](/_images/database/mysql/advance/索引分类.png)

## 问题

1. 为什么要设计索引？   
    * 加快数据的访问效率，可以直接根据 值 ————> 数据
2. 如何设计索引？ 	
    * 数据的存储载体在磁盘里，即根据key值找到存储的文件，再通过偏移完成数据的查找
    - 1.关键值:key
    - 2.文件名称
    - 3.偏移量 offset
3. 设计索引的时候使用什么数据结构？ 
    * hash索引,B树，B+树
4. MySql是如何实现的？
    * B+树索引+ hash索引

## 各类索引特点

hash索引:

```
优点:直接根据key找到对应的value;
缺点:hash存储需要将所有数据文件存储在内存;
	 等值查询速度快，范围查询的话，需要多次查找
	 哈希冲突
二叉树和红黑树的索引格式:
都会因为树的深度造成IO次数变多，从而影响效率
```

B树的索引格式：

```
每一个节点存储三个数据，关键码，指向子树的指针和关键码个数；
B树的每一个节点都既包含索引，又包含数据
从而导致按照磁盘页（4K*N）读取数据的时候，存储的内容变少。
```

B+树的索引格式：

```
B+树当中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。
所以同样大小的磁盘页可以容纳更多的节点元素。这意味着，数据量相同的情况下,
B+树的结构比B-树更加矮胖，因此查询时IO次数也更少。
因此MySql选择B+树的索引格式。
```

在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

* InnoDB   B+树索引
* MyISAM   B+树索引
* MEMORY   hash索引

# 索引结构

优点：

* 提高数据检索效率，降低数据库的IO成本
* 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗

缺点：

* 索引列也是要占用空间的
* 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE

## 概述

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：

| 索引结构  | 描述  |
| ------------ | ------------ |
| B+Tree  | 最常见的索引类型，大部分引擎都支持B+树索引  |
| Hash  | 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询  |
| R-Tree(空间索引)  | 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少  |
| Full-Text(全文索引)  | 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES  |

不同的存储引擎对于索引结构的支持情况

| 索引  | InnoDB  | MyISAM  | Memory  |
| ------------ | ------------ | ------------ | ------------ |
| B+Tree索引  | 支持  | 支持  | 支持  |
| Hash索引  | 不支持  | 不支持  | 支持  |
| R-Tree索引  | 不支持  | 支持  | 不支持  |
| Full-text  | 5.6版本后支持  | 支持  | 不支持  |

> 注意：平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。

## 二叉树

MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下图左边的结构。

如果主键是顺序插入的，则会形成一个单向链表，结构如下图右边的结构：

![](/_images/database/mysql/advance/二叉树.png)

所以，如果选择二叉树作为索引结构，会存在以下缺点：

* 顺序插入时，会形成一个链表，查询性能大大降低。
* 大数据量情况下，层级较深，检索速度慢。

更进一步地，可以选择红黑树，利用其自平衡的特点，即使在 `顺序插入` 的场景下，也能达到平衡效果。

![](/_images/database/mysql/advance/红黑树.png)

但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：

* 红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。

为了解决上述问题，可以使用 B-Tree 结构。

## B-Tree

B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：

![](/_images/database/mysql/advance/B-Tree.png)

特点：

* 5阶的B树，每一个节点最多存储4个key，对应5个指针。
* 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。
* 在B树中，非叶子节点和叶子节点都会存放数据

## B+Tree

B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：

![](/_images/database/mysql/advance/B+Tree.png)

* 绿色部分：索引部分，仅仅起到索引数据的作用，不存储数据。
* 红色部分：数据存储部分，在其叶子节点中要存储具体的数据。

> 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html

B+Tree 与 B-Tree相比，主要有以下三点区别：

* 所有的数据都会出现在叶子节点。
* 叶子节点形成一个单向链表。
* 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。

MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能（**双向链表**）。

![](/_images/database/mysql/advance/B+Tree+.png)

## Hash

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。

* 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。

![](/_images/database/mysql/advance/Hash索引.png)

特点：

- Hash索引只能用于对等比较（=、in），**不支持范围查询**（betwwn、>、<、...）
- 无法利用索引完成排序操作
- 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引

存储引擎支持：

- Memory
- InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的

### 思考

> 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？

- 相对于二叉树，层级更少，搜索效率高
- 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
- 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作

# 索引分类

## 概述

> 在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。

| 分类  | 含义  | 特点  | 关键字  |
| ------------ | ------------ | ------------ | ------------ |
| 主键索引  | 针对于表中主键创建的索引  | 默认自动创建，只能有一个  | PRIMARY  |
| 唯一索引  | 避免同一个表中某数据列中的值重复  | 可以有多个  | UNIQUE  |
| 常规索引  | 快速定位特定数据  | 可以有多个  |   |
| 全文索引  | 全文索引查找的是文本中的关键词，而不是比较索引中的值  | 可以有多个  | FULLTEXT  |

## 聚集索引&二级索引

在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类  | 含义  | 特点  |
| ------------ | ------------ | ------------ |
| 聚集索引(Clustered Index)  | 将数据存储与索引放一块，索引结构的叶子节点保存了行数据  | 必须有，而且只有一个  |
| 二级索引(Secondary Index)  | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键  | 可以存在多个  |

**聚集索引选取规则**:

* 如果存在主键，主键索引就是聚集索引。
* 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
* 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

聚集索引和二级索引的具体结构如下：

![](/_images/database/mysql/advance/聚集索引+二级索引.png)

* 聚集索引的叶子节点下挂的是这一行的数据 。
* 二级索引的叶子节点下挂的是该字段值对应的主键值。

执行如下的SQL语句时，具体的查找过程：

![](/_images/database/mysql/advance/SQL执行查询过程.png)

具体过程如下:

1. 由于是根据name字段进行查询，所以先根据name='Arm'到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。
2. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。
3. 最终拿到这一行的数据，直接返回即可。

> **回表查询**：这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。

### 思考题

> InnoDB 主键索引的 B+Tree 高度为多少？

答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.
可得公式：`n * 8 + (n + 1) * 6 = 16 * 1024`，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。

* 如果树的高度为2，那么他能存储的数据量大概为：`1171 * 16 = 18736`；
* 如果树的高度为3，那么他能存储的数据量大概为：`1171 * 1171 * 16 = 21939856`。

另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。

# 索引语法

创建索引：
`CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);`
如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引

查看索引：
`SHOW INDEX FROM table_name;`

删除索引：
`DROP INDEX index_name ON table_name;`

案例：

创建一张表 tb_user, 并且查询测试数据。

<<< @/md/database/mysql/src/tb_user.sql

查询结果：

![](/_images/database/mysql/advance/tb_user_rows.png)

操作索引：

```mysql
-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引
create index idx_user_name on tb_user(name);
-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引
create unique index idx_user_phone on tb_user (phone);
-- 为profession, age, status创建联合索引
create index idx_user_pro_age_stat on tb_user(profession, age, status);
-- 为age建立合适的索引来提升查询效率
create index idx_user_age on tb_user(age);
-- 为email建立合适的索引来提升查询效率
create index idx_user_email on tb_user(email);
-- 查看tb_user表所有的索引数据
show index from tb_user;

-- 删除索引
drop index idx_user_email on tb_user;
```

![](/_images/database/mysql/advance/tb_user_indexs.png)
